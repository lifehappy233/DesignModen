# 设计模式

![2](./pg/2.png)



## 面向对象设计原则



**依赖倒置原则（DIP）**

* 高层模块（稳定）不应该依赖与底层模块（变化），二者都应该依赖于抽象（稳定）。
* 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。

![1](pg/1.jpg)

**开放封闭原则（OCP）**

* 对扩展开放，对更改封闭。
* 类模块应该是可扩展的，但是不可修改。

**单一职责原则（SRP）**

* 一个类应该仅有一个引起它变化的原因。
* 变化的方向隐含着类的责任。

**Liskov替换原则（LSP）**

* 子类必须能够替换他们的基类（IS-A）。
* 继承表达类型抽象。

**接口隔离原则（ISP）**

* 不应该强迫客户程序依赖他们不用的方法。
* 接口应该小而完备。

**优先使用对象组合，而不是类继承**

* 类继承通常为“白箱复用”，对象组合通常为“黑箱服用”。
* 继承在某种程度上破坏了封装性，子类父耦合度高。
* 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低。

**封装变化点**

* 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。

**针对接口编程，而不是针对实现编程**

* 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
* 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。
* 减少系统中各部分的依赖关系，从而实现“高内聚，松耦合”的类型设计方案。



## 重构关键技法

* 静态 -> 动态。
* 早绑定 -> 晚绑定。
* 继承 -> 组合。
* 编译时依赖 -> 运行时依赖。
* 紧耦合 -> 松耦合。



## 一、模版方法（Template）

背景：在软件构建过程中，对于某一项任务，常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（框架与应用之间的关系）而无法和任务的整体结构同时实现。

实现：定义一个操作中的算法骨架（稳定），而将一些步骤延迟到子类中。使得子类可以不改变（复用）一个算法的结构即可重定义该算法的某些特定步骤。

```shell
code/template
├── improve
│   ├── app.go
│   └── lib
│       └── lib.go
└── initial
    ├── app.go
    └── lib
        └── lib.go
```




## 二、策略模式（Strategy）

背景：在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂，而且有时候支持不使用的算法也是一个性能负担。

实现：定义一系列算法，把它们一个一个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。

```shell
code/strategy
├── improve
│   └── tax.go
└── initial
    └── tax.go
```



## 三、观察者模式（Observer）

背景：在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系”——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。

实现：定义对象间的一种多对多（变化）的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

```shell
code/observer
├── imporve
│   ├── clock.go
│   └── clocktimer
│       └── clocktimer.go
└── initial
    └── clock.go
```



## 四、装饰模式（Decorator）

背景：某些情况下可能会“过度地使用继承来扩展对象的功能”，由于继承为类型引入的静态特质，使得这种扩展方式缺乏灵活性：并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀。

实现：动态（组合）地给一个对象增加一些额外的职责。九增加功能而言，Decorator模式比生产子类（继承）更为灵活（消除重复代码、减少子类个数）。

```shell
code/decorator
├── improve
│   ├── main.go
│   └── stream
│       └── stream.go
└── initial
    ├── main.go
    └── stream
        ├── filestream
        │   └── filestream.go
        ├── memorystream
        │   └── memorystream.go
        ├── networkstream
        │   └── networkstream.go
        └── stream.go
```



## 五、桥模式（Bridge）

背景：由于某些类型的固有的实现逻辑，使得它们具有两个变化的维度，乃至多个维度的变化。

实现：将抽象部分（业务功能）于实现部分（平台实现）分离，使它们都可以独立地变化。

```shell
code/bridge
├── improve
│   ├── main.go
│   └── messager
│       ├── messager.go
│       ├── mobilemessager
│       │   └── mobilemessager.go
│       └── pcmessager
│           └── pcmessager.go
└── initial
    ├── main.go
    └── messager
        ├── messager.go
        ├── mobilemessager
        │   └── mobilemessager.go
        └── pcmessager
            └── pcmessager.go
```



## 六、工厂方法（Factory Method）

背景：在软件系统中，经常面临着创建对象的工作；由于需求的变化，需要创建的对象的具体类型经常变化。

实现：定义一个用于创建对象的接口，让子类决定实力化哪个类，使得一个类的实例化延迟。

```shell
code/factorymethod
├── improve
│   ├── main.go
│   └── splitter
│       ├── base.go
│       └── specific.go
└── initial
    ├── main.go
    └── splitter
        └── splitter.go
```



## 七、抽象工厂（Abstract Factory）

背景：在软件系统中，经常面临着“一系列相互依赖的对象”的创建工作；同时，由于需求的变化，往往存在更多系列对象的创建工作。

实现：提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。

```shell
code/abstractfactory
├── improve
│   ├── database
│   │   ├── database.go
│   │   ├── oracle
│   │   │   └── oracle.go
│   │   └── sql
│   │       └── sql.go
│   └── main.go
└── initial
    ├── database
    │   ├── databases.go
    │   ├── oracle
    │   │   └── oracle.go
    │   └── sql
    │       └── sql.go
    └── main.go
```



## *八、原型模式（Prototype）

背景：在软件系统中，经常面临着“某些结构复杂的对象“的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。

实现：使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。



## *九、构建器（Builder）

背景：在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。

实现：将一个复杂对象的构建与其表示相分离，使得同样的构建过程（稳定）可以创建不同的表示（变化）。



## 十、单件模式（Singleton）

背景：在软件系统之，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能保证它们的逻辑正确性和良好的效率。

实现：保证一个类只有一个实例，并提供一个该实例的全局访问点。

```shell
code/singleton
├── improve
│   └── main.go
└── initial
    └── main.go
```



## *十一、享元模式（Flyweight）

背景：在软件系统采用纯粹对象方案的问题在于大量细粒度的对象会很快充斥在系统中，从而带来很高的运行时代价——主要指内存需求方面的代价。

实现：使用共享技术有效地支持大量粒度的对象。



## 十二、门面模式（Facade）

![3](./pg/3.png)背景：组件的客户和组件中各种复杂的子系统有过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临着很多变化的挑战。

实现：为子系统中的一组接口提供一个一致（稳定）的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用（复用）。

​		

## 十三、代理模式



## 十四、适配器



## 十五、中介者



## 十六、状态模式



## 十七、备忘录



## 十八、组合模式



## 十九、迭代器



## 二十、职责链



## 二一、命令模式



## 二二、访问器



## 二三、解析器



  

